// Code generated by counterfeiter. DO NOT EDIT.
package fake_routing_api

import (
	"sync"

	routing_api "code.cloudfoundry.org/routing-release/routing-api"
	"code.cloudfoundry.org/routing-release/routing-api/models"
)

type FakeClient struct {
	CreateRouterGroupStub        func(models.RouterGroup) error
	createRouterGroupMutex       sync.RWMutex
	createRouterGroupArgsForCall []struct {
		arg1 models.RouterGroup
	}
	createRouterGroupReturns struct {
		result1 error
	}
	createRouterGroupReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteRouterGroupStub        func(models.RouterGroup) error
	deleteRouterGroupMutex       sync.RWMutex
	deleteRouterGroupArgsForCall []struct {
		arg1 models.RouterGroup
	}
	deleteRouterGroupReturns struct {
		result1 error
	}
	deleteRouterGroupReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteRoutesStub        func([]models.Route) error
	deleteRoutesMutex       sync.RWMutex
	deleteRoutesArgsForCall []struct {
		arg1 []models.Route
	}
	deleteRoutesReturns struct {
		result1 error
	}
	deleteRoutesReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteTcpRouteMappingsStub        func([]models.TcpRouteMapping) error
	deleteTcpRouteMappingsMutex       sync.RWMutex
	deleteTcpRouteMappingsArgsForCall []struct {
		arg1 []models.TcpRouteMapping
	}
	deleteTcpRouteMappingsReturns struct {
		result1 error
	}
	deleteTcpRouteMappingsReturnsOnCall map[int]struct {
		result1 error
	}
	FilteredTcpRouteMappingsStub        func([]string) ([]models.TcpRouteMapping, error)
	filteredTcpRouteMappingsMutex       sync.RWMutex
	filteredTcpRouteMappingsArgsForCall []struct {
		arg1 []string
	}
	filteredTcpRouteMappingsReturns struct {
		result1 []models.TcpRouteMapping
		result2 error
	}
	filteredTcpRouteMappingsReturnsOnCall map[int]struct {
		result1 []models.TcpRouteMapping
		result2 error
	}
	ReservePortStub        func(string, string) (int, error)
	reservePortMutex       sync.RWMutex
	reservePortArgsForCall []struct {
		arg1 string
		arg2 string
	}
	reservePortReturns struct {
		result1 int
		result2 error
	}
	reservePortReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	RouterGroupWithNameStub        func(string) (models.RouterGroup, error)
	routerGroupWithNameMutex       sync.RWMutex
	routerGroupWithNameArgsForCall []struct {
		arg1 string
	}
	routerGroupWithNameReturns struct {
		result1 models.RouterGroup
		result2 error
	}
	routerGroupWithNameReturnsOnCall map[int]struct {
		result1 models.RouterGroup
		result2 error
	}
	RouterGroupsStub        func() ([]models.RouterGroup, error)
	routerGroupsMutex       sync.RWMutex
	routerGroupsArgsForCall []struct {
	}
	routerGroupsReturns struct {
		result1 []models.RouterGroup
		result2 error
	}
	routerGroupsReturnsOnCall map[int]struct {
		result1 []models.RouterGroup
		result2 error
	}
	RoutesStub        func() ([]models.Route, error)
	routesMutex       sync.RWMutex
	routesArgsForCall []struct {
	}
	routesReturns struct {
		result1 []models.Route
		result2 error
	}
	routesReturnsOnCall map[int]struct {
		result1 []models.Route
		result2 error
	}
	SetTokenStub        func(string)
	setTokenMutex       sync.RWMutex
	setTokenArgsForCall []struct {
		arg1 string
	}
	SubscribeToEventsStub        func() (routing_api.EventSource, error)
	subscribeToEventsMutex       sync.RWMutex
	subscribeToEventsArgsForCall []struct {
	}
	subscribeToEventsReturns struct {
		result1 routing_api.EventSource
		result2 error
	}
	subscribeToEventsReturnsOnCall map[int]struct {
		result1 routing_api.EventSource
		result2 error
	}
	SubscribeToEventsWithMaxRetriesStub        func(uint16) (routing_api.EventSource, error)
	subscribeToEventsWithMaxRetriesMutex       sync.RWMutex
	subscribeToEventsWithMaxRetriesArgsForCall []struct {
		arg1 uint16
	}
	subscribeToEventsWithMaxRetriesReturns struct {
		result1 routing_api.EventSource
		result2 error
	}
	subscribeToEventsWithMaxRetriesReturnsOnCall map[int]struct {
		result1 routing_api.EventSource
		result2 error
	}
	SubscribeToTcpEventsStub        func() (routing_api.TcpEventSource, error)
	subscribeToTcpEventsMutex       sync.RWMutex
	subscribeToTcpEventsArgsForCall []struct {
	}
	subscribeToTcpEventsReturns struct {
		result1 routing_api.TcpEventSource
		result2 error
	}
	subscribeToTcpEventsReturnsOnCall map[int]struct {
		result1 routing_api.TcpEventSource
		result2 error
	}
	SubscribeToTcpEventsWithMaxRetriesStub        func(uint16) (routing_api.TcpEventSource, error)
	subscribeToTcpEventsWithMaxRetriesMutex       sync.RWMutex
	subscribeToTcpEventsWithMaxRetriesArgsForCall []struct {
		arg1 uint16
	}
	subscribeToTcpEventsWithMaxRetriesReturns struct {
		result1 routing_api.TcpEventSource
		result2 error
	}
	subscribeToTcpEventsWithMaxRetriesReturnsOnCall map[int]struct {
		result1 routing_api.TcpEventSource
		result2 error
	}
	TcpRouteMappingsStub        func() ([]models.TcpRouteMapping, error)
	tcpRouteMappingsMutex       sync.RWMutex
	tcpRouteMappingsArgsForCall []struct {
	}
	tcpRouteMappingsReturns struct {
		result1 []models.TcpRouteMapping
		result2 error
	}
	tcpRouteMappingsReturnsOnCall map[int]struct {
		result1 []models.TcpRouteMapping
		result2 error
	}
	UpdateRouterGroupStub        func(models.RouterGroup) error
	updateRouterGroupMutex       sync.RWMutex
	updateRouterGroupArgsForCall []struct {
		arg1 models.RouterGroup
	}
	updateRouterGroupReturns struct {
		result1 error
	}
	updateRouterGroupReturnsOnCall map[int]struct {
		result1 error
	}
	UpsertRoutesStub        func([]models.Route) error
	upsertRoutesMutex       sync.RWMutex
	upsertRoutesArgsForCall []struct {
		arg1 []models.Route
	}
	upsertRoutesReturns struct {
		result1 error
	}
	upsertRoutesReturnsOnCall map[int]struct {
		result1 error
	}
	UpsertTcpRouteMappingsStub        func([]models.TcpRouteMapping) error
	upsertTcpRouteMappingsMutex       sync.RWMutex
	upsertTcpRouteMappingsArgsForCall []struct {
		arg1 []models.TcpRouteMapping
	}
	upsertTcpRouteMappingsReturns struct {
		result1 error
	}
	upsertTcpRouteMappingsReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) CreateRouterGroup(arg1 models.RouterGroup) error {
	fake.createRouterGroupMutex.Lock()
	ret, specificReturn := fake.createRouterGroupReturnsOnCall[len(fake.createRouterGroupArgsForCall)]
	fake.createRouterGroupArgsForCall = append(fake.createRouterGroupArgsForCall, struct {
		arg1 models.RouterGroup
	}{arg1})
	fake.recordInvocation("CreateRouterGroup", []interface{}{arg1})
	fake.createRouterGroupMutex.Unlock()
	if fake.CreateRouterGroupStub != nil {
		return fake.CreateRouterGroupStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createRouterGroupReturns
	return fakeReturns.result1
}

func (fake *FakeClient) CreateRouterGroupCallCount() int {
	fake.createRouterGroupMutex.RLock()
	defer fake.createRouterGroupMutex.RUnlock()
	return len(fake.createRouterGroupArgsForCall)
}

func (fake *FakeClient) CreateRouterGroupCalls(stub func(models.RouterGroup) error) {
	fake.createRouterGroupMutex.Lock()
	defer fake.createRouterGroupMutex.Unlock()
	fake.CreateRouterGroupStub = stub
}

func (fake *FakeClient) CreateRouterGroupArgsForCall(i int) models.RouterGroup {
	fake.createRouterGroupMutex.RLock()
	defer fake.createRouterGroupMutex.RUnlock()
	argsForCall := fake.createRouterGroupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CreateRouterGroupReturns(result1 error) {
	fake.createRouterGroupMutex.Lock()
	defer fake.createRouterGroupMutex.Unlock()
	fake.CreateRouterGroupStub = nil
	fake.createRouterGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CreateRouterGroupReturnsOnCall(i int, result1 error) {
	fake.createRouterGroupMutex.Lock()
	defer fake.createRouterGroupMutex.Unlock()
	fake.CreateRouterGroupStub = nil
	if fake.createRouterGroupReturnsOnCall == nil {
		fake.createRouterGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createRouterGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteRouterGroup(arg1 models.RouterGroup) error {
	fake.deleteRouterGroupMutex.Lock()
	ret, specificReturn := fake.deleteRouterGroupReturnsOnCall[len(fake.deleteRouterGroupArgsForCall)]
	fake.deleteRouterGroupArgsForCall = append(fake.deleteRouterGroupArgsForCall, struct {
		arg1 models.RouterGroup
	}{arg1})
	fake.recordInvocation("DeleteRouterGroup", []interface{}{arg1})
	fake.deleteRouterGroupMutex.Unlock()
	if fake.DeleteRouterGroupStub != nil {
		return fake.DeleteRouterGroupStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteRouterGroupReturns
	return fakeReturns.result1
}

func (fake *FakeClient) DeleteRouterGroupCallCount() int {
	fake.deleteRouterGroupMutex.RLock()
	defer fake.deleteRouterGroupMutex.RUnlock()
	return len(fake.deleteRouterGroupArgsForCall)
}

func (fake *FakeClient) DeleteRouterGroupCalls(stub func(models.RouterGroup) error) {
	fake.deleteRouterGroupMutex.Lock()
	defer fake.deleteRouterGroupMutex.Unlock()
	fake.DeleteRouterGroupStub = stub
}

func (fake *FakeClient) DeleteRouterGroupArgsForCall(i int) models.RouterGroup {
	fake.deleteRouterGroupMutex.RLock()
	defer fake.deleteRouterGroupMutex.RUnlock()
	argsForCall := fake.deleteRouterGroupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DeleteRouterGroupReturns(result1 error) {
	fake.deleteRouterGroupMutex.Lock()
	defer fake.deleteRouterGroupMutex.Unlock()
	fake.DeleteRouterGroupStub = nil
	fake.deleteRouterGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteRouterGroupReturnsOnCall(i int, result1 error) {
	fake.deleteRouterGroupMutex.Lock()
	defer fake.deleteRouterGroupMutex.Unlock()
	fake.DeleteRouterGroupStub = nil
	if fake.deleteRouterGroupReturnsOnCall == nil {
		fake.deleteRouterGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteRouterGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteRoutes(arg1 []models.Route) error {
	var arg1Copy []models.Route
	if arg1 != nil {
		arg1Copy = make([]models.Route, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.deleteRoutesMutex.Lock()
	ret, specificReturn := fake.deleteRoutesReturnsOnCall[len(fake.deleteRoutesArgsForCall)]
	fake.deleteRoutesArgsForCall = append(fake.deleteRoutesArgsForCall, struct {
		arg1 []models.Route
	}{arg1Copy})
	fake.recordInvocation("DeleteRoutes", []interface{}{arg1Copy})
	fake.deleteRoutesMutex.Unlock()
	if fake.DeleteRoutesStub != nil {
		return fake.DeleteRoutesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteRoutesReturns
	return fakeReturns.result1
}

func (fake *FakeClient) DeleteRoutesCallCount() int {
	fake.deleteRoutesMutex.RLock()
	defer fake.deleteRoutesMutex.RUnlock()
	return len(fake.deleteRoutesArgsForCall)
}

func (fake *FakeClient) DeleteRoutesCalls(stub func([]models.Route) error) {
	fake.deleteRoutesMutex.Lock()
	defer fake.deleteRoutesMutex.Unlock()
	fake.DeleteRoutesStub = stub
}

func (fake *FakeClient) DeleteRoutesArgsForCall(i int) []models.Route {
	fake.deleteRoutesMutex.RLock()
	defer fake.deleteRoutesMutex.RUnlock()
	argsForCall := fake.deleteRoutesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DeleteRoutesReturns(result1 error) {
	fake.deleteRoutesMutex.Lock()
	defer fake.deleteRoutesMutex.Unlock()
	fake.DeleteRoutesStub = nil
	fake.deleteRoutesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteRoutesReturnsOnCall(i int, result1 error) {
	fake.deleteRoutesMutex.Lock()
	defer fake.deleteRoutesMutex.Unlock()
	fake.DeleteRoutesStub = nil
	if fake.deleteRoutesReturnsOnCall == nil {
		fake.deleteRoutesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteRoutesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteTcpRouteMappings(arg1 []models.TcpRouteMapping) error {
	var arg1Copy []models.TcpRouteMapping
	if arg1 != nil {
		arg1Copy = make([]models.TcpRouteMapping, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.deleteTcpRouteMappingsMutex.Lock()
	ret, specificReturn := fake.deleteTcpRouteMappingsReturnsOnCall[len(fake.deleteTcpRouteMappingsArgsForCall)]
	fake.deleteTcpRouteMappingsArgsForCall = append(fake.deleteTcpRouteMappingsArgsForCall, struct {
		arg1 []models.TcpRouteMapping
	}{arg1Copy})
	fake.recordInvocation("DeleteTcpRouteMappings", []interface{}{arg1Copy})
	fake.deleteTcpRouteMappingsMutex.Unlock()
	if fake.DeleteTcpRouteMappingsStub != nil {
		return fake.DeleteTcpRouteMappingsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteTcpRouteMappingsReturns
	return fakeReturns.result1
}

func (fake *FakeClient) DeleteTcpRouteMappingsCallCount() int {
	fake.deleteTcpRouteMappingsMutex.RLock()
	defer fake.deleteTcpRouteMappingsMutex.RUnlock()
	return len(fake.deleteTcpRouteMappingsArgsForCall)
}

func (fake *FakeClient) DeleteTcpRouteMappingsCalls(stub func([]models.TcpRouteMapping) error) {
	fake.deleteTcpRouteMappingsMutex.Lock()
	defer fake.deleteTcpRouteMappingsMutex.Unlock()
	fake.DeleteTcpRouteMappingsStub = stub
}

func (fake *FakeClient) DeleteTcpRouteMappingsArgsForCall(i int) []models.TcpRouteMapping {
	fake.deleteTcpRouteMappingsMutex.RLock()
	defer fake.deleteTcpRouteMappingsMutex.RUnlock()
	argsForCall := fake.deleteTcpRouteMappingsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) DeleteTcpRouteMappingsReturns(result1 error) {
	fake.deleteTcpRouteMappingsMutex.Lock()
	defer fake.deleteTcpRouteMappingsMutex.Unlock()
	fake.DeleteTcpRouteMappingsStub = nil
	fake.deleteTcpRouteMappingsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DeleteTcpRouteMappingsReturnsOnCall(i int, result1 error) {
	fake.deleteTcpRouteMappingsMutex.Lock()
	defer fake.deleteTcpRouteMappingsMutex.Unlock()
	fake.DeleteTcpRouteMappingsStub = nil
	if fake.deleteTcpRouteMappingsReturnsOnCall == nil {
		fake.deleteTcpRouteMappingsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteTcpRouteMappingsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) FilteredTcpRouteMappings(arg1 []string) ([]models.TcpRouteMapping, error) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.filteredTcpRouteMappingsMutex.Lock()
	ret, specificReturn := fake.filteredTcpRouteMappingsReturnsOnCall[len(fake.filteredTcpRouteMappingsArgsForCall)]
	fake.filteredTcpRouteMappingsArgsForCall = append(fake.filteredTcpRouteMappingsArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	fake.recordInvocation("FilteredTcpRouteMappings", []interface{}{arg1Copy})
	fake.filteredTcpRouteMappingsMutex.Unlock()
	if fake.FilteredTcpRouteMappingsStub != nil {
		return fake.FilteredTcpRouteMappingsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.filteredTcpRouteMappingsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) FilteredTcpRouteMappingsCallCount() int {
	fake.filteredTcpRouteMappingsMutex.RLock()
	defer fake.filteredTcpRouteMappingsMutex.RUnlock()
	return len(fake.filteredTcpRouteMappingsArgsForCall)
}

func (fake *FakeClient) FilteredTcpRouteMappingsCalls(stub func([]string) ([]models.TcpRouteMapping, error)) {
	fake.filteredTcpRouteMappingsMutex.Lock()
	defer fake.filteredTcpRouteMappingsMutex.Unlock()
	fake.FilteredTcpRouteMappingsStub = stub
}

func (fake *FakeClient) FilteredTcpRouteMappingsArgsForCall(i int) []string {
	fake.filteredTcpRouteMappingsMutex.RLock()
	defer fake.filteredTcpRouteMappingsMutex.RUnlock()
	argsForCall := fake.filteredTcpRouteMappingsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) FilteredTcpRouteMappingsReturns(result1 []models.TcpRouteMapping, result2 error) {
	fake.filteredTcpRouteMappingsMutex.Lock()
	defer fake.filteredTcpRouteMappingsMutex.Unlock()
	fake.FilteredTcpRouteMappingsStub = nil
	fake.filteredTcpRouteMappingsReturns = struct {
		result1 []models.TcpRouteMapping
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) FilteredTcpRouteMappingsReturnsOnCall(i int, result1 []models.TcpRouteMapping, result2 error) {
	fake.filteredTcpRouteMappingsMutex.Lock()
	defer fake.filteredTcpRouteMappingsMutex.Unlock()
	fake.FilteredTcpRouteMappingsStub = nil
	if fake.filteredTcpRouteMappingsReturnsOnCall == nil {
		fake.filteredTcpRouteMappingsReturnsOnCall = make(map[int]struct {
			result1 []models.TcpRouteMapping
			result2 error
		})
	}
	fake.filteredTcpRouteMappingsReturnsOnCall[i] = struct {
		result1 []models.TcpRouteMapping
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ReservePort(arg1 string, arg2 string) (int, error) {
	fake.reservePortMutex.Lock()
	ret, specificReturn := fake.reservePortReturnsOnCall[len(fake.reservePortArgsForCall)]
	fake.reservePortArgsForCall = append(fake.reservePortArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("ReservePort", []interface{}{arg1, arg2})
	fake.reservePortMutex.Unlock()
	if fake.ReservePortStub != nil {
		return fake.ReservePortStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.reservePortReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ReservePortCallCount() int {
	fake.reservePortMutex.RLock()
	defer fake.reservePortMutex.RUnlock()
	return len(fake.reservePortArgsForCall)
}

func (fake *FakeClient) ReservePortCalls(stub func(string, string) (int, error)) {
	fake.reservePortMutex.Lock()
	defer fake.reservePortMutex.Unlock()
	fake.ReservePortStub = stub
}

func (fake *FakeClient) ReservePortArgsForCall(i int) (string, string) {
	fake.reservePortMutex.RLock()
	defer fake.reservePortMutex.RUnlock()
	argsForCall := fake.reservePortArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) ReservePortReturns(result1 int, result2 error) {
	fake.reservePortMutex.Lock()
	defer fake.reservePortMutex.Unlock()
	fake.ReservePortStub = nil
	fake.reservePortReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ReservePortReturnsOnCall(i int, result1 int, result2 error) {
	fake.reservePortMutex.Lock()
	defer fake.reservePortMutex.Unlock()
	fake.ReservePortStub = nil
	if fake.reservePortReturnsOnCall == nil {
		fake.reservePortReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.reservePortReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RouterGroupWithName(arg1 string) (models.RouterGroup, error) {
	fake.routerGroupWithNameMutex.Lock()
	ret, specificReturn := fake.routerGroupWithNameReturnsOnCall[len(fake.routerGroupWithNameArgsForCall)]
	fake.routerGroupWithNameArgsForCall = append(fake.routerGroupWithNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("RouterGroupWithName", []interface{}{arg1})
	fake.routerGroupWithNameMutex.Unlock()
	if fake.RouterGroupWithNameStub != nil {
		return fake.RouterGroupWithNameStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.routerGroupWithNameReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) RouterGroupWithNameCallCount() int {
	fake.routerGroupWithNameMutex.RLock()
	defer fake.routerGroupWithNameMutex.RUnlock()
	return len(fake.routerGroupWithNameArgsForCall)
}

func (fake *FakeClient) RouterGroupWithNameCalls(stub func(string) (models.RouterGroup, error)) {
	fake.routerGroupWithNameMutex.Lock()
	defer fake.routerGroupWithNameMutex.Unlock()
	fake.RouterGroupWithNameStub = stub
}

func (fake *FakeClient) RouterGroupWithNameArgsForCall(i int) string {
	fake.routerGroupWithNameMutex.RLock()
	defer fake.routerGroupWithNameMutex.RUnlock()
	argsForCall := fake.routerGroupWithNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) RouterGroupWithNameReturns(result1 models.RouterGroup, result2 error) {
	fake.routerGroupWithNameMutex.Lock()
	defer fake.routerGroupWithNameMutex.Unlock()
	fake.RouterGroupWithNameStub = nil
	fake.routerGroupWithNameReturns = struct {
		result1 models.RouterGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RouterGroupWithNameReturnsOnCall(i int, result1 models.RouterGroup, result2 error) {
	fake.routerGroupWithNameMutex.Lock()
	defer fake.routerGroupWithNameMutex.Unlock()
	fake.RouterGroupWithNameStub = nil
	if fake.routerGroupWithNameReturnsOnCall == nil {
		fake.routerGroupWithNameReturnsOnCall = make(map[int]struct {
			result1 models.RouterGroup
			result2 error
		})
	}
	fake.routerGroupWithNameReturnsOnCall[i] = struct {
		result1 models.RouterGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RouterGroups() ([]models.RouterGroup, error) {
	fake.routerGroupsMutex.Lock()
	ret, specificReturn := fake.routerGroupsReturnsOnCall[len(fake.routerGroupsArgsForCall)]
	fake.routerGroupsArgsForCall = append(fake.routerGroupsArgsForCall, struct {
	}{})
	fake.recordInvocation("RouterGroups", []interface{}{})
	fake.routerGroupsMutex.Unlock()
	if fake.RouterGroupsStub != nil {
		return fake.RouterGroupsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.routerGroupsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) RouterGroupsCallCount() int {
	fake.routerGroupsMutex.RLock()
	defer fake.routerGroupsMutex.RUnlock()
	return len(fake.routerGroupsArgsForCall)
}

func (fake *FakeClient) RouterGroupsCalls(stub func() ([]models.RouterGroup, error)) {
	fake.routerGroupsMutex.Lock()
	defer fake.routerGroupsMutex.Unlock()
	fake.RouterGroupsStub = stub
}

func (fake *FakeClient) RouterGroupsReturns(result1 []models.RouterGroup, result2 error) {
	fake.routerGroupsMutex.Lock()
	defer fake.routerGroupsMutex.Unlock()
	fake.RouterGroupsStub = nil
	fake.routerGroupsReturns = struct {
		result1 []models.RouterGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RouterGroupsReturnsOnCall(i int, result1 []models.RouterGroup, result2 error) {
	fake.routerGroupsMutex.Lock()
	defer fake.routerGroupsMutex.Unlock()
	fake.RouterGroupsStub = nil
	if fake.routerGroupsReturnsOnCall == nil {
		fake.routerGroupsReturnsOnCall = make(map[int]struct {
			result1 []models.RouterGroup
			result2 error
		})
	}
	fake.routerGroupsReturnsOnCall[i] = struct {
		result1 []models.RouterGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Routes() ([]models.Route, error) {
	fake.routesMutex.Lock()
	ret, specificReturn := fake.routesReturnsOnCall[len(fake.routesArgsForCall)]
	fake.routesArgsForCall = append(fake.routesArgsForCall, struct {
	}{})
	fake.recordInvocation("Routes", []interface{}{})
	fake.routesMutex.Unlock()
	if fake.RoutesStub != nil {
		return fake.RoutesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.routesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) RoutesCallCount() int {
	fake.routesMutex.RLock()
	defer fake.routesMutex.RUnlock()
	return len(fake.routesArgsForCall)
}

func (fake *FakeClient) RoutesCalls(stub func() ([]models.Route, error)) {
	fake.routesMutex.Lock()
	defer fake.routesMutex.Unlock()
	fake.RoutesStub = stub
}

func (fake *FakeClient) RoutesReturns(result1 []models.Route, result2 error) {
	fake.routesMutex.Lock()
	defer fake.routesMutex.Unlock()
	fake.RoutesStub = nil
	fake.routesReturns = struct {
		result1 []models.Route
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) RoutesReturnsOnCall(i int, result1 []models.Route, result2 error) {
	fake.routesMutex.Lock()
	defer fake.routesMutex.Unlock()
	fake.RoutesStub = nil
	if fake.routesReturnsOnCall == nil {
		fake.routesReturnsOnCall = make(map[int]struct {
			result1 []models.Route
			result2 error
		})
	}
	fake.routesReturnsOnCall[i] = struct {
		result1 []models.Route
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SetToken(arg1 string) {
	fake.setTokenMutex.Lock()
	fake.setTokenArgsForCall = append(fake.setTokenArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("SetToken", []interface{}{arg1})
	fake.setTokenMutex.Unlock()
	if fake.SetTokenStub != nil {
		fake.SetTokenStub(arg1)
	}
}

func (fake *FakeClient) SetTokenCallCount() int {
	fake.setTokenMutex.RLock()
	defer fake.setTokenMutex.RUnlock()
	return len(fake.setTokenArgsForCall)
}

func (fake *FakeClient) SetTokenCalls(stub func(string)) {
	fake.setTokenMutex.Lock()
	defer fake.setTokenMutex.Unlock()
	fake.SetTokenStub = stub
}

func (fake *FakeClient) SetTokenArgsForCall(i int) string {
	fake.setTokenMutex.RLock()
	defer fake.setTokenMutex.RUnlock()
	argsForCall := fake.setTokenArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) SubscribeToEvents() (routing_api.EventSource, error) {
	fake.subscribeToEventsMutex.Lock()
	ret, specificReturn := fake.subscribeToEventsReturnsOnCall[len(fake.subscribeToEventsArgsForCall)]
	fake.subscribeToEventsArgsForCall = append(fake.subscribeToEventsArgsForCall, struct {
	}{})
	fake.recordInvocation("SubscribeToEvents", []interface{}{})
	fake.subscribeToEventsMutex.Unlock()
	if fake.SubscribeToEventsStub != nil {
		return fake.SubscribeToEventsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.subscribeToEventsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) SubscribeToEventsCallCount() int {
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	return len(fake.subscribeToEventsArgsForCall)
}

func (fake *FakeClient) SubscribeToEventsCalls(stub func() (routing_api.EventSource, error)) {
	fake.subscribeToEventsMutex.Lock()
	defer fake.subscribeToEventsMutex.Unlock()
	fake.SubscribeToEventsStub = stub
}

func (fake *FakeClient) SubscribeToEventsReturns(result1 routing_api.EventSource, result2 error) {
	fake.subscribeToEventsMutex.Lock()
	defer fake.subscribeToEventsMutex.Unlock()
	fake.SubscribeToEventsStub = nil
	fake.subscribeToEventsReturns = struct {
		result1 routing_api.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToEventsReturnsOnCall(i int, result1 routing_api.EventSource, result2 error) {
	fake.subscribeToEventsMutex.Lock()
	defer fake.subscribeToEventsMutex.Unlock()
	fake.SubscribeToEventsStub = nil
	if fake.subscribeToEventsReturnsOnCall == nil {
		fake.subscribeToEventsReturnsOnCall = make(map[int]struct {
			result1 routing_api.EventSource
			result2 error
		})
	}
	fake.subscribeToEventsReturnsOnCall[i] = struct {
		result1 routing_api.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToEventsWithMaxRetries(arg1 uint16) (routing_api.EventSource, error) {
	fake.subscribeToEventsWithMaxRetriesMutex.Lock()
	ret, specificReturn := fake.subscribeToEventsWithMaxRetriesReturnsOnCall[len(fake.subscribeToEventsWithMaxRetriesArgsForCall)]
	fake.subscribeToEventsWithMaxRetriesArgsForCall = append(fake.subscribeToEventsWithMaxRetriesArgsForCall, struct {
		arg1 uint16
	}{arg1})
	fake.recordInvocation("SubscribeToEventsWithMaxRetries", []interface{}{arg1})
	fake.subscribeToEventsWithMaxRetriesMutex.Unlock()
	if fake.SubscribeToEventsWithMaxRetriesStub != nil {
		return fake.SubscribeToEventsWithMaxRetriesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.subscribeToEventsWithMaxRetriesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) SubscribeToEventsWithMaxRetriesCallCount() int {
	fake.subscribeToEventsWithMaxRetriesMutex.RLock()
	defer fake.subscribeToEventsWithMaxRetriesMutex.RUnlock()
	return len(fake.subscribeToEventsWithMaxRetriesArgsForCall)
}

func (fake *FakeClient) SubscribeToEventsWithMaxRetriesCalls(stub func(uint16) (routing_api.EventSource, error)) {
	fake.subscribeToEventsWithMaxRetriesMutex.Lock()
	defer fake.subscribeToEventsWithMaxRetriesMutex.Unlock()
	fake.SubscribeToEventsWithMaxRetriesStub = stub
}

func (fake *FakeClient) SubscribeToEventsWithMaxRetriesArgsForCall(i int) uint16 {
	fake.subscribeToEventsWithMaxRetriesMutex.RLock()
	defer fake.subscribeToEventsWithMaxRetriesMutex.RUnlock()
	argsForCall := fake.subscribeToEventsWithMaxRetriesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) SubscribeToEventsWithMaxRetriesReturns(result1 routing_api.EventSource, result2 error) {
	fake.subscribeToEventsWithMaxRetriesMutex.Lock()
	defer fake.subscribeToEventsWithMaxRetriesMutex.Unlock()
	fake.SubscribeToEventsWithMaxRetriesStub = nil
	fake.subscribeToEventsWithMaxRetriesReturns = struct {
		result1 routing_api.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToEventsWithMaxRetriesReturnsOnCall(i int, result1 routing_api.EventSource, result2 error) {
	fake.subscribeToEventsWithMaxRetriesMutex.Lock()
	defer fake.subscribeToEventsWithMaxRetriesMutex.Unlock()
	fake.SubscribeToEventsWithMaxRetriesStub = nil
	if fake.subscribeToEventsWithMaxRetriesReturnsOnCall == nil {
		fake.subscribeToEventsWithMaxRetriesReturnsOnCall = make(map[int]struct {
			result1 routing_api.EventSource
			result2 error
		})
	}
	fake.subscribeToEventsWithMaxRetriesReturnsOnCall[i] = struct {
		result1 routing_api.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToTcpEvents() (routing_api.TcpEventSource, error) {
	fake.subscribeToTcpEventsMutex.Lock()
	ret, specificReturn := fake.subscribeToTcpEventsReturnsOnCall[len(fake.subscribeToTcpEventsArgsForCall)]
	fake.subscribeToTcpEventsArgsForCall = append(fake.subscribeToTcpEventsArgsForCall, struct {
	}{})
	fake.recordInvocation("SubscribeToTcpEvents", []interface{}{})
	fake.subscribeToTcpEventsMutex.Unlock()
	if fake.SubscribeToTcpEventsStub != nil {
		return fake.SubscribeToTcpEventsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.subscribeToTcpEventsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) SubscribeToTcpEventsCallCount() int {
	fake.subscribeToTcpEventsMutex.RLock()
	defer fake.subscribeToTcpEventsMutex.RUnlock()
	return len(fake.subscribeToTcpEventsArgsForCall)
}

func (fake *FakeClient) SubscribeToTcpEventsCalls(stub func() (routing_api.TcpEventSource, error)) {
	fake.subscribeToTcpEventsMutex.Lock()
	defer fake.subscribeToTcpEventsMutex.Unlock()
	fake.SubscribeToTcpEventsStub = stub
}

func (fake *FakeClient) SubscribeToTcpEventsReturns(result1 routing_api.TcpEventSource, result2 error) {
	fake.subscribeToTcpEventsMutex.Lock()
	defer fake.subscribeToTcpEventsMutex.Unlock()
	fake.SubscribeToTcpEventsStub = nil
	fake.subscribeToTcpEventsReturns = struct {
		result1 routing_api.TcpEventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToTcpEventsReturnsOnCall(i int, result1 routing_api.TcpEventSource, result2 error) {
	fake.subscribeToTcpEventsMutex.Lock()
	defer fake.subscribeToTcpEventsMutex.Unlock()
	fake.SubscribeToTcpEventsStub = nil
	if fake.subscribeToTcpEventsReturnsOnCall == nil {
		fake.subscribeToTcpEventsReturnsOnCall = make(map[int]struct {
			result1 routing_api.TcpEventSource
			result2 error
		})
	}
	fake.subscribeToTcpEventsReturnsOnCall[i] = struct {
		result1 routing_api.TcpEventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToTcpEventsWithMaxRetries(arg1 uint16) (routing_api.TcpEventSource, error) {
	fake.subscribeToTcpEventsWithMaxRetriesMutex.Lock()
	ret, specificReturn := fake.subscribeToTcpEventsWithMaxRetriesReturnsOnCall[len(fake.subscribeToTcpEventsWithMaxRetriesArgsForCall)]
	fake.subscribeToTcpEventsWithMaxRetriesArgsForCall = append(fake.subscribeToTcpEventsWithMaxRetriesArgsForCall, struct {
		arg1 uint16
	}{arg1})
	fake.recordInvocation("SubscribeToTcpEventsWithMaxRetries", []interface{}{arg1})
	fake.subscribeToTcpEventsWithMaxRetriesMutex.Unlock()
	if fake.SubscribeToTcpEventsWithMaxRetriesStub != nil {
		return fake.SubscribeToTcpEventsWithMaxRetriesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.subscribeToTcpEventsWithMaxRetriesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) SubscribeToTcpEventsWithMaxRetriesCallCount() int {
	fake.subscribeToTcpEventsWithMaxRetriesMutex.RLock()
	defer fake.subscribeToTcpEventsWithMaxRetriesMutex.RUnlock()
	return len(fake.subscribeToTcpEventsWithMaxRetriesArgsForCall)
}

func (fake *FakeClient) SubscribeToTcpEventsWithMaxRetriesCalls(stub func(uint16) (routing_api.TcpEventSource, error)) {
	fake.subscribeToTcpEventsWithMaxRetriesMutex.Lock()
	defer fake.subscribeToTcpEventsWithMaxRetriesMutex.Unlock()
	fake.SubscribeToTcpEventsWithMaxRetriesStub = stub
}

func (fake *FakeClient) SubscribeToTcpEventsWithMaxRetriesArgsForCall(i int) uint16 {
	fake.subscribeToTcpEventsWithMaxRetriesMutex.RLock()
	defer fake.subscribeToTcpEventsWithMaxRetriesMutex.RUnlock()
	argsForCall := fake.subscribeToTcpEventsWithMaxRetriesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) SubscribeToTcpEventsWithMaxRetriesReturns(result1 routing_api.TcpEventSource, result2 error) {
	fake.subscribeToTcpEventsWithMaxRetriesMutex.Lock()
	defer fake.subscribeToTcpEventsWithMaxRetriesMutex.Unlock()
	fake.SubscribeToTcpEventsWithMaxRetriesStub = nil
	fake.subscribeToTcpEventsWithMaxRetriesReturns = struct {
		result1 routing_api.TcpEventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SubscribeToTcpEventsWithMaxRetriesReturnsOnCall(i int, result1 routing_api.TcpEventSource, result2 error) {
	fake.subscribeToTcpEventsWithMaxRetriesMutex.Lock()
	defer fake.subscribeToTcpEventsWithMaxRetriesMutex.Unlock()
	fake.SubscribeToTcpEventsWithMaxRetriesStub = nil
	if fake.subscribeToTcpEventsWithMaxRetriesReturnsOnCall == nil {
		fake.subscribeToTcpEventsWithMaxRetriesReturnsOnCall = make(map[int]struct {
			result1 routing_api.TcpEventSource
			result2 error
		})
	}
	fake.subscribeToTcpEventsWithMaxRetriesReturnsOnCall[i] = struct {
		result1 routing_api.TcpEventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) TcpRouteMappings() ([]models.TcpRouteMapping, error) {
	fake.tcpRouteMappingsMutex.Lock()
	ret, specificReturn := fake.tcpRouteMappingsReturnsOnCall[len(fake.tcpRouteMappingsArgsForCall)]
	fake.tcpRouteMappingsArgsForCall = append(fake.tcpRouteMappingsArgsForCall, struct {
	}{})
	fake.recordInvocation("TcpRouteMappings", []interface{}{})
	fake.tcpRouteMappingsMutex.Unlock()
	if fake.TcpRouteMappingsStub != nil {
		return fake.TcpRouteMappingsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.tcpRouteMappingsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) TcpRouteMappingsCallCount() int {
	fake.tcpRouteMappingsMutex.RLock()
	defer fake.tcpRouteMappingsMutex.RUnlock()
	return len(fake.tcpRouteMappingsArgsForCall)
}

func (fake *FakeClient) TcpRouteMappingsCalls(stub func() ([]models.TcpRouteMapping, error)) {
	fake.tcpRouteMappingsMutex.Lock()
	defer fake.tcpRouteMappingsMutex.Unlock()
	fake.TcpRouteMappingsStub = stub
}

func (fake *FakeClient) TcpRouteMappingsReturns(result1 []models.TcpRouteMapping, result2 error) {
	fake.tcpRouteMappingsMutex.Lock()
	defer fake.tcpRouteMappingsMutex.Unlock()
	fake.TcpRouteMappingsStub = nil
	fake.tcpRouteMappingsReturns = struct {
		result1 []models.TcpRouteMapping
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) TcpRouteMappingsReturnsOnCall(i int, result1 []models.TcpRouteMapping, result2 error) {
	fake.tcpRouteMappingsMutex.Lock()
	defer fake.tcpRouteMappingsMutex.Unlock()
	fake.TcpRouteMappingsStub = nil
	if fake.tcpRouteMappingsReturnsOnCall == nil {
		fake.tcpRouteMappingsReturnsOnCall = make(map[int]struct {
			result1 []models.TcpRouteMapping
			result2 error
		})
	}
	fake.tcpRouteMappingsReturnsOnCall[i] = struct {
		result1 []models.TcpRouteMapping
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) UpdateRouterGroup(arg1 models.RouterGroup) error {
	fake.updateRouterGroupMutex.Lock()
	ret, specificReturn := fake.updateRouterGroupReturnsOnCall[len(fake.updateRouterGroupArgsForCall)]
	fake.updateRouterGroupArgsForCall = append(fake.updateRouterGroupArgsForCall, struct {
		arg1 models.RouterGroup
	}{arg1})
	fake.recordInvocation("UpdateRouterGroup", []interface{}{arg1})
	fake.updateRouterGroupMutex.Unlock()
	if fake.UpdateRouterGroupStub != nil {
		return fake.UpdateRouterGroupStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateRouterGroupReturns
	return fakeReturns.result1
}

func (fake *FakeClient) UpdateRouterGroupCallCount() int {
	fake.updateRouterGroupMutex.RLock()
	defer fake.updateRouterGroupMutex.RUnlock()
	return len(fake.updateRouterGroupArgsForCall)
}

func (fake *FakeClient) UpdateRouterGroupCalls(stub func(models.RouterGroup) error) {
	fake.updateRouterGroupMutex.Lock()
	defer fake.updateRouterGroupMutex.Unlock()
	fake.UpdateRouterGroupStub = stub
}

func (fake *FakeClient) UpdateRouterGroupArgsForCall(i int) models.RouterGroup {
	fake.updateRouterGroupMutex.RLock()
	defer fake.updateRouterGroupMutex.RUnlock()
	argsForCall := fake.updateRouterGroupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) UpdateRouterGroupReturns(result1 error) {
	fake.updateRouterGroupMutex.Lock()
	defer fake.updateRouterGroupMutex.Unlock()
	fake.UpdateRouterGroupStub = nil
	fake.updateRouterGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpdateRouterGroupReturnsOnCall(i int, result1 error) {
	fake.updateRouterGroupMutex.Lock()
	defer fake.updateRouterGroupMutex.Unlock()
	fake.UpdateRouterGroupStub = nil
	if fake.updateRouterGroupReturnsOnCall == nil {
		fake.updateRouterGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateRouterGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpsertRoutes(arg1 []models.Route) error {
	var arg1Copy []models.Route
	if arg1 != nil {
		arg1Copy = make([]models.Route, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.upsertRoutesMutex.Lock()
	ret, specificReturn := fake.upsertRoutesReturnsOnCall[len(fake.upsertRoutesArgsForCall)]
	fake.upsertRoutesArgsForCall = append(fake.upsertRoutesArgsForCall, struct {
		arg1 []models.Route
	}{arg1Copy})
	fake.recordInvocation("UpsertRoutes", []interface{}{arg1Copy})
	fake.upsertRoutesMutex.Unlock()
	if fake.UpsertRoutesStub != nil {
		return fake.UpsertRoutesStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.upsertRoutesReturns
	return fakeReturns.result1
}

func (fake *FakeClient) UpsertRoutesCallCount() int {
	fake.upsertRoutesMutex.RLock()
	defer fake.upsertRoutesMutex.RUnlock()
	return len(fake.upsertRoutesArgsForCall)
}

func (fake *FakeClient) UpsertRoutesCalls(stub func([]models.Route) error) {
	fake.upsertRoutesMutex.Lock()
	defer fake.upsertRoutesMutex.Unlock()
	fake.UpsertRoutesStub = stub
}

func (fake *FakeClient) UpsertRoutesArgsForCall(i int) []models.Route {
	fake.upsertRoutesMutex.RLock()
	defer fake.upsertRoutesMutex.RUnlock()
	argsForCall := fake.upsertRoutesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) UpsertRoutesReturns(result1 error) {
	fake.upsertRoutesMutex.Lock()
	defer fake.upsertRoutesMutex.Unlock()
	fake.UpsertRoutesStub = nil
	fake.upsertRoutesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpsertRoutesReturnsOnCall(i int, result1 error) {
	fake.upsertRoutesMutex.Lock()
	defer fake.upsertRoutesMutex.Unlock()
	fake.UpsertRoutesStub = nil
	if fake.upsertRoutesReturnsOnCall == nil {
		fake.upsertRoutesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upsertRoutesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpsertTcpRouteMappings(arg1 []models.TcpRouteMapping) error {
	var arg1Copy []models.TcpRouteMapping
	if arg1 != nil {
		arg1Copy = make([]models.TcpRouteMapping, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.upsertTcpRouteMappingsMutex.Lock()
	ret, specificReturn := fake.upsertTcpRouteMappingsReturnsOnCall[len(fake.upsertTcpRouteMappingsArgsForCall)]
	fake.upsertTcpRouteMappingsArgsForCall = append(fake.upsertTcpRouteMappingsArgsForCall, struct {
		arg1 []models.TcpRouteMapping
	}{arg1Copy})
	fake.recordInvocation("UpsertTcpRouteMappings", []interface{}{arg1Copy})
	fake.upsertTcpRouteMappingsMutex.Unlock()
	if fake.UpsertTcpRouteMappingsStub != nil {
		return fake.UpsertTcpRouteMappingsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.upsertTcpRouteMappingsReturns
	return fakeReturns.result1
}

func (fake *FakeClient) UpsertTcpRouteMappingsCallCount() int {
	fake.upsertTcpRouteMappingsMutex.RLock()
	defer fake.upsertTcpRouteMappingsMutex.RUnlock()
	return len(fake.upsertTcpRouteMappingsArgsForCall)
}

func (fake *FakeClient) UpsertTcpRouteMappingsCalls(stub func([]models.TcpRouteMapping) error) {
	fake.upsertTcpRouteMappingsMutex.Lock()
	defer fake.upsertTcpRouteMappingsMutex.Unlock()
	fake.UpsertTcpRouteMappingsStub = stub
}

func (fake *FakeClient) UpsertTcpRouteMappingsArgsForCall(i int) []models.TcpRouteMapping {
	fake.upsertTcpRouteMappingsMutex.RLock()
	defer fake.upsertTcpRouteMappingsMutex.RUnlock()
	argsForCall := fake.upsertTcpRouteMappingsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) UpsertTcpRouteMappingsReturns(result1 error) {
	fake.upsertTcpRouteMappingsMutex.Lock()
	defer fake.upsertTcpRouteMappingsMutex.Unlock()
	fake.UpsertTcpRouteMappingsStub = nil
	fake.upsertTcpRouteMappingsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) UpsertTcpRouteMappingsReturnsOnCall(i int, result1 error) {
	fake.upsertTcpRouteMappingsMutex.Lock()
	defer fake.upsertTcpRouteMappingsMutex.Unlock()
	fake.UpsertTcpRouteMappingsStub = nil
	if fake.upsertTcpRouteMappingsReturnsOnCall == nil {
		fake.upsertTcpRouteMappingsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upsertTcpRouteMappingsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createRouterGroupMutex.RLock()
	defer fake.createRouterGroupMutex.RUnlock()
	fake.deleteRouterGroupMutex.RLock()
	defer fake.deleteRouterGroupMutex.RUnlock()
	fake.deleteRoutesMutex.RLock()
	defer fake.deleteRoutesMutex.RUnlock()
	fake.deleteTcpRouteMappingsMutex.RLock()
	defer fake.deleteTcpRouteMappingsMutex.RUnlock()
	fake.filteredTcpRouteMappingsMutex.RLock()
	defer fake.filteredTcpRouteMappingsMutex.RUnlock()
	fake.reservePortMutex.RLock()
	defer fake.reservePortMutex.RUnlock()
	fake.routerGroupWithNameMutex.RLock()
	defer fake.routerGroupWithNameMutex.RUnlock()
	fake.routerGroupsMutex.RLock()
	defer fake.routerGroupsMutex.RUnlock()
	fake.routesMutex.RLock()
	defer fake.routesMutex.RUnlock()
	fake.setTokenMutex.RLock()
	defer fake.setTokenMutex.RUnlock()
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	fake.subscribeToEventsWithMaxRetriesMutex.RLock()
	defer fake.subscribeToEventsWithMaxRetriesMutex.RUnlock()
	fake.subscribeToTcpEventsMutex.RLock()
	defer fake.subscribeToTcpEventsMutex.RUnlock()
	fake.subscribeToTcpEventsWithMaxRetriesMutex.RLock()
	defer fake.subscribeToTcpEventsWithMaxRetriesMutex.RUnlock()
	fake.tcpRouteMappingsMutex.RLock()
	defer fake.tcpRouteMappingsMutex.RUnlock()
	fake.updateRouterGroupMutex.RLock()
	defer fake.updateRouterGroupMutex.RUnlock()
	fake.upsertRoutesMutex.RLock()
	defer fake.upsertRoutesMutex.RUnlock()
	fake.upsertTcpRouteMappingsMutex.RLock()
	defer fake.upsertTcpRouteMappingsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ routing_api.Client = new(FakeClient)
