// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"sync"

	"code.cloudfoundry.org/routing-release/routing-api/db"
	"code.cloudfoundry.org/routing-release/routing-api/models"
)

type FakeDB struct {
	CancelWatchesStub        func()
	cancelWatchesMutex       sync.RWMutex
	cancelWatchesArgsForCall []struct {
	}
	DeleteRouteStub        func(models.Route) error
	deleteRouteMutex       sync.RWMutex
	deleteRouteArgsForCall []struct {
		arg1 models.Route
	}
	deleteRouteReturns struct {
		result1 error
	}
	deleteRouteReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteRouterGroupStub        func(string) error
	deleteRouterGroupMutex       sync.RWMutex
	deleteRouterGroupArgsForCall []struct {
		arg1 string
	}
	deleteRouterGroupReturns struct {
		result1 error
	}
	deleteRouterGroupReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteTcpRouteMappingStub        func(models.TcpRouteMapping) error
	deleteTcpRouteMappingMutex       sync.RWMutex
	deleteTcpRouteMappingArgsForCall []struct {
		arg1 models.TcpRouteMapping
	}
	deleteTcpRouteMappingReturns struct {
		result1 error
	}
	deleteTcpRouteMappingReturnsOnCall map[int]struct {
		result1 error
	}
	LockRouterGroupReadsStub        func()
	lockRouterGroupReadsMutex       sync.RWMutex
	lockRouterGroupReadsArgsForCall []struct {
	}
	LockRouterGroupWritesStub        func()
	lockRouterGroupWritesMutex       sync.RWMutex
	lockRouterGroupWritesArgsForCall []struct {
	}
	ReadFilteredTcpRouteMappingsStub        func(string, []string) ([]models.TcpRouteMapping, error)
	readFilteredTcpRouteMappingsMutex       sync.RWMutex
	readFilteredTcpRouteMappingsArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	readFilteredTcpRouteMappingsReturns struct {
		result1 []models.TcpRouteMapping
		result2 error
	}
	readFilteredTcpRouteMappingsReturnsOnCall map[int]struct {
		result1 []models.TcpRouteMapping
		result2 error
	}
	ReadRouterGroupStub        func(string) (models.RouterGroup, error)
	readRouterGroupMutex       sync.RWMutex
	readRouterGroupArgsForCall []struct {
		arg1 string
	}
	readRouterGroupReturns struct {
		result1 models.RouterGroup
		result2 error
	}
	readRouterGroupReturnsOnCall map[int]struct {
		result1 models.RouterGroup
		result2 error
	}
	ReadRouterGroupByNameStub        func(string) (models.RouterGroup, error)
	readRouterGroupByNameMutex       sync.RWMutex
	readRouterGroupByNameArgsForCall []struct {
		arg1 string
	}
	readRouterGroupByNameReturns struct {
		result1 models.RouterGroup
		result2 error
	}
	readRouterGroupByNameReturnsOnCall map[int]struct {
		result1 models.RouterGroup
		result2 error
	}
	ReadRouterGroupsStub        func() (models.RouterGroups, error)
	readRouterGroupsMutex       sync.RWMutex
	readRouterGroupsArgsForCall []struct {
	}
	readRouterGroupsReturns struct {
		result1 models.RouterGroups
		result2 error
	}
	readRouterGroupsReturnsOnCall map[int]struct {
		result1 models.RouterGroups
		result2 error
	}
	ReadRoutesStub        func() ([]models.Route, error)
	readRoutesMutex       sync.RWMutex
	readRoutesArgsForCall []struct {
	}
	readRoutesReturns struct {
		result1 []models.Route
		result2 error
	}
	readRoutesReturnsOnCall map[int]struct {
		result1 []models.Route
		result2 error
	}
	ReadTcpRouteMappingsStub        func() ([]models.TcpRouteMapping, error)
	readTcpRouteMappingsMutex       sync.RWMutex
	readTcpRouteMappingsArgsForCall []struct {
	}
	readTcpRouteMappingsReturns struct {
		result1 []models.TcpRouteMapping
		result2 error
	}
	readTcpRouteMappingsReturnsOnCall map[int]struct {
		result1 []models.TcpRouteMapping
		result2 error
	}
	SaveRouteStub        func(models.Route) error
	saveRouteMutex       sync.RWMutex
	saveRouteArgsForCall []struct {
		arg1 models.Route
	}
	saveRouteReturns struct {
		result1 error
	}
	saveRouteReturnsOnCall map[int]struct {
		result1 error
	}
	SaveRouterGroupStub        func(models.RouterGroup) error
	saveRouterGroupMutex       sync.RWMutex
	saveRouterGroupArgsForCall []struct {
		arg1 models.RouterGroup
	}
	saveRouterGroupReturns struct {
		result1 error
	}
	saveRouterGroupReturnsOnCall map[int]struct {
		result1 error
	}
	SaveTcpRouteMappingStub        func(models.TcpRouteMapping) error
	saveTcpRouteMappingMutex       sync.RWMutex
	saveTcpRouteMappingArgsForCall []struct {
		arg1 models.TcpRouteMapping
	}
	saveTcpRouteMappingReturns struct {
		result1 error
	}
	saveTcpRouteMappingReturnsOnCall map[int]struct {
		result1 error
	}
	UnlockRouterGroupReadsStub        func()
	unlockRouterGroupReadsMutex       sync.RWMutex
	unlockRouterGroupReadsArgsForCall []struct {
	}
	UnlockRouterGroupWritesStub        func()
	unlockRouterGroupWritesMutex       sync.RWMutex
	unlockRouterGroupWritesArgsForCall []struct {
	}
	WatchChangesStub        func(string) (<-chan db.Event, <-chan error, context.CancelFunc)
	watchChangesMutex       sync.RWMutex
	watchChangesArgsForCall []struct {
		arg1 string
	}
	watchChangesReturns struct {
		result1 <-chan db.Event
		result2 <-chan error
		result3 context.CancelFunc
	}
	watchChangesReturnsOnCall map[int]struct {
		result1 <-chan db.Event
		result2 <-chan error
		result3 context.CancelFunc
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDB) CancelWatches() {
	fake.cancelWatchesMutex.Lock()
	fake.cancelWatchesArgsForCall = append(fake.cancelWatchesArgsForCall, struct {
	}{})
	fake.recordInvocation("CancelWatches", []interface{}{})
	fake.cancelWatchesMutex.Unlock()
	if fake.CancelWatchesStub != nil {
		fake.CancelWatchesStub()
	}
}

func (fake *FakeDB) CancelWatchesCallCount() int {
	fake.cancelWatchesMutex.RLock()
	defer fake.cancelWatchesMutex.RUnlock()
	return len(fake.cancelWatchesArgsForCall)
}

func (fake *FakeDB) CancelWatchesCalls(stub func()) {
	fake.cancelWatchesMutex.Lock()
	defer fake.cancelWatchesMutex.Unlock()
	fake.CancelWatchesStub = stub
}

func (fake *FakeDB) DeleteRoute(arg1 models.Route) error {
	fake.deleteRouteMutex.Lock()
	ret, specificReturn := fake.deleteRouteReturnsOnCall[len(fake.deleteRouteArgsForCall)]
	fake.deleteRouteArgsForCall = append(fake.deleteRouteArgsForCall, struct {
		arg1 models.Route
	}{arg1})
	fake.recordInvocation("DeleteRoute", []interface{}{arg1})
	fake.deleteRouteMutex.Unlock()
	if fake.DeleteRouteStub != nil {
		return fake.DeleteRouteStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteRouteReturns
	return fakeReturns.result1
}

func (fake *FakeDB) DeleteRouteCallCount() int {
	fake.deleteRouteMutex.RLock()
	defer fake.deleteRouteMutex.RUnlock()
	return len(fake.deleteRouteArgsForCall)
}

func (fake *FakeDB) DeleteRouteCalls(stub func(models.Route) error) {
	fake.deleteRouteMutex.Lock()
	defer fake.deleteRouteMutex.Unlock()
	fake.DeleteRouteStub = stub
}

func (fake *FakeDB) DeleteRouteArgsForCall(i int) models.Route {
	fake.deleteRouteMutex.RLock()
	defer fake.deleteRouteMutex.RUnlock()
	argsForCall := fake.deleteRouteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDB) DeleteRouteReturns(result1 error) {
	fake.deleteRouteMutex.Lock()
	defer fake.deleteRouteMutex.Unlock()
	fake.DeleteRouteStub = nil
	fake.deleteRouteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) DeleteRouteReturnsOnCall(i int, result1 error) {
	fake.deleteRouteMutex.Lock()
	defer fake.deleteRouteMutex.Unlock()
	fake.DeleteRouteStub = nil
	if fake.deleteRouteReturnsOnCall == nil {
		fake.deleteRouteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteRouteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) DeleteRouterGroup(arg1 string) error {
	fake.deleteRouterGroupMutex.Lock()
	ret, specificReturn := fake.deleteRouterGroupReturnsOnCall[len(fake.deleteRouterGroupArgsForCall)]
	fake.deleteRouterGroupArgsForCall = append(fake.deleteRouterGroupArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DeleteRouterGroup", []interface{}{arg1})
	fake.deleteRouterGroupMutex.Unlock()
	if fake.DeleteRouterGroupStub != nil {
		return fake.DeleteRouterGroupStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteRouterGroupReturns
	return fakeReturns.result1
}

func (fake *FakeDB) DeleteRouterGroupCallCount() int {
	fake.deleteRouterGroupMutex.RLock()
	defer fake.deleteRouterGroupMutex.RUnlock()
	return len(fake.deleteRouterGroupArgsForCall)
}

func (fake *FakeDB) DeleteRouterGroupCalls(stub func(string) error) {
	fake.deleteRouterGroupMutex.Lock()
	defer fake.deleteRouterGroupMutex.Unlock()
	fake.DeleteRouterGroupStub = stub
}

func (fake *FakeDB) DeleteRouterGroupArgsForCall(i int) string {
	fake.deleteRouterGroupMutex.RLock()
	defer fake.deleteRouterGroupMutex.RUnlock()
	argsForCall := fake.deleteRouterGroupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDB) DeleteRouterGroupReturns(result1 error) {
	fake.deleteRouterGroupMutex.Lock()
	defer fake.deleteRouterGroupMutex.Unlock()
	fake.DeleteRouterGroupStub = nil
	fake.deleteRouterGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) DeleteRouterGroupReturnsOnCall(i int, result1 error) {
	fake.deleteRouterGroupMutex.Lock()
	defer fake.deleteRouterGroupMutex.Unlock()
	fake.DeleteRouterGroupStub = nil
	if fake.deleteRouterGroupReturnsOnCall == nil {
		fake.deleteRouterGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteRouterGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) DeleteTcpRouteMapping(arg1 models.TcpRouteMapping) error {
	fake.deleteTcpRouteMappingMutex.Lock()
	ret, specificReturn := fake.deleteTcpRouteMappingReturnsOnCall[len(fake.deleteTcpRouteMappingArgsForCall)]
	fake.deleteTcpRouteMappingArgsForCall = append(fake.deleteTcpRouteMappingArgsForCall, struct {
		arg1 models.TcpRouteMapping
	}{arg1})
	fake.recordInvocation("DeleteTcpRouteMapping", []interface{}{arg1})
	fake.deleteTcpRouteMappingMutex.Unlock()
	if fake.DeleteTcpRouteMappingStub != nil {
		return fake.DeleteTcpRouteMappingStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteTcpRouteMappingReturns
	return fakeReturns.result1
}

func (fake *FakeDB) DeleteTcpRouteMappingCallCount() int {
	fake.deleteTcpRouteMappingMutex.RLock()
	defer fake.deleteTcpRouteMappingMutex.RUnlock()
	return len(fake.deleteTcpRouteMappingArgsForCall)
}

func (fake *FakeDB) DeleteTcpRouteMappingCalls(stub func(models.TcpRouteMapping) error) {
	fake.deleteTcpRouteMappingMutex.Lock()
	defer fake.deleteTcpRouteMappingMutex.Unlock()
	fake.DeleteTcpRouteMappingStub = stub
}

func (fake *FakeDB) DeleteTcpRouteMappingArgsForCall(i int) models.TcpRouteMapping {
	fake.deleteTcpRouteMappingMutex.RLock()
	defer fake.deleteTcpRouteMappingMutex.RUnlock()
	argsForCall := fake.deleteTcpRouteMappingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDB) DeleteTcpRouteMappingReturns(result1 error) {
	fake.deleteTcpRouteMappingMutex.Lock()
	defer fake.deleteTcpRouteMappingMutex.Unlock()
	fake.DeleteTcpRouteMappingStub = nil
	fake.deleteTcpRouteMappingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) DeleteTcpRouteMappingReturnsOnCall(i int, result1 error) {
	fake.deleteTcpRouteMappingMutex.Lock()
	defer fake.deleteTcpRouteMappingMutex.Unlock()
	fake.DeleteTcpRouteMappingStub = nil
	if fake.deleteTcpRouteMappingReturnsOnCall == nil {
		fake.deleteTcpRouteMappingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteTcpRouteMappingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) LockRouterGroupReads() {
	fake.lockRouterGroupReadsMutex.Lock()
	fake.lockRouterGroupReadsArgsForCall = append(fake.lockRouterGroupReadsArgsForCall, struct {
	}{})
	fake.recordInvocation("LockRouterGroupReads", []interface{}{})
	fake.lockRouterGroupReadsMutex.Unlock()
	if fake.LockRouterGroupReadsStub != nil {
		fake.LockRouterGroupReadsStub()
	}
}

func (fake *FakeDB) LockRouterGroupReadsCallCount() int {
	fake.lockRouterGroupReadsMutex.RLock()
	defer fake.lockRouterGroupReadsMutex.RUnlock()
	return len(fake.lockRouterGroupReadsArgsForCall)
}

func (fake *FakeDB) LockRouterGroupReadsCalls(stub func()) {
	fake.lockRouterGroupReadsMutex.Lock()
	defer fake.lockRouterGroupReadsMutex.Unlock()
	fake.LockRouterGroupReadsStub = stub
}

func (fake *FakeDB) LockRouterGroupWrites() {
	fake.lockRouterGroupWritesMutex.Lock()
	fake.lockRouterGroupWritesArgsForCall = append(fake.lockRouterGroupWritesArgsForCall, struct {
	}{})
	fake.recordInvocation("LockRouterGroupWrites", []interface{}{})
	fake.lockRouterGroupWritesMutex.Unlock()
	if fake.LockRouterGroupWritesStub != nil {
		fake.LockRouterGroupWritesStub()
	}
}

func (fake *FakeDB) LockRouterGroupWritesCallCount() int {
	fake.lockRouterGroupWritesMutex.RLock()
	defer fake.lockRouterGroupWritesMutex.RUnlock()
	return len(fake.lockRouterGroupWritesArgsForCall)
}

func (fake *FakeDB) LockRouterGroupWritesCalls(stub func()) {
	fake.lockRouterGroupWritesMutex.Lock()
	defer fake.lockRouterGroupWritesMutex.Unlock()
	fake.LockRouterGroupWritesStub = stub
}

func (fake *FakeDB) ReadFilteredTcpRouteMappings(arg1 string, arg2 []string) ([]models.TcpRouteMapping, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.readFilteredTcpRouteMappingsMutex.Lock()
	ret, specificReturn := fake.readFilteredTcpRouteMappingsReturnsOnCall[len(fake.readFilteredTcpRouteMappingsArgsForCall)]
	fake.readFilteredTcpRouteMappingsArgsForCall = append(fake.readFilteredTcpRouteMappingsArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	fake.recordInvocation("ReadFilteredTcpRouteMappings", []interface{}{arg1, arg2Copy})
	fake.readFilteredTcpRouteMappingsMutex.Unlock()
	if fake.ReadFilteredTcpRouteMappingsStub != nil {
		return fake.ReadFilteredTcpRouteMappingsStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.readFilteredTcpRouteMappingsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) ReadFilteredTcpRouteMappingsCallCount() int {
	fake.readFilteredTcpRouteMappingsMutex.RLock()
	defer fake.readFilteredTcpRouteMappingsMutex.RUnlock()
	return len(fake.readFilteredTcpRouteMappingsArgsForCall)
}

func (fake *FakeDB) ReadFilteredTcpRouteMappingsCalls(stub func(string, []string) ([]models.TcpRouteMapping, error)) {
	fake.readFilteredTcpRouteMappingsMutex.Lock()
	defer fake.readFilteredTcpRouteMappingsMutex.Unlock()
	fake.ReadFilteredTcpRouteMappingsStub = stub
}

func (fake *FakeDB) ReadFilteredTcpRouteMappingsArgsForCall(i int) (string, []string) {
	fake.readFilteredTcpRouteMappingsMutex.RLock()
	defer fake.readFilteredTcpRouteMappingsMutex.RUnlock()
	argsForCall := fake.readFilteredTcpRouteMappingsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDB) ReadFilteredTcpRouteMappingsReturns(result1 []models.TcpRouteMapping, result2 error) {
	fake.readFilteredTcpRouteMappingsMutex.Lock()
	defer fake.readFilteredTcpRouteMappingsMutex.Unlock()
	fake.ReadFilteredTcpRouteMappingsStub = nil
	fake.readFilteredTcpRouteMappingsReturns = struct {
		result1 []models.TcpRouteMapping
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) ReadFilteredTcpRouteMappingsReturnsOnCall(i int, result1 []models.TcpRouteMapping, result2 error) {
	fake.readFilteredTcpRouteMappingsMutex.Lock()
	defer fake.readFilteredTcpRouteMappingsMutex.Unlock()
	fake.ReadFilteredTcpRouteMappingsStub = nil
	if fake.readFilteredTcpRouteMappingsReturnsOnCall == nil {
		fake.readFilteredTcpRouteMappingsReturnsOnCall = make(map[int]struct {
			result1 []models.TcpRouteMapping
			result2 error
		})
	}
	fake.readFilteredTcpRouteMappingsReturnsOnCall[i] = struct {
		result1 []models.TcpRouteMapping
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) ReadRouterGroup(arg1 string) (models.RouterGroup, error) {
	fake.readRouterGroupMutex.Lock()
	ret, specificReturn := fake.readRouterGroupReturnsOnCall[len(fake.readRouterGroupArgsForCall)]
	fake.readRouterGroupArgsForCall = append(fake.readRouterGroupArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ReadRouterGroup", []interface{}{arg1})
	fake.readRouterGroupMutex.Unlock()
	if fake.ReadRouterGroupStub != nil {
		return fake.ReadRouterGroupStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.readRouterGroupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) ReadRouterGroupCallCount() int {
	fake.readRouterGroupMutex.RLock()
	defer fake.readRouterGroupMutex.RUnlock()
	return len(fake.readRouterGroupArgsForCall)
}

func (fake *FakeDB) ReadRouterGroupCalls(stub func(string) (models.RouterGroup, error)) {
	fake.readRouterGroupMutex.Lock()
	defer fake.readRouterGroupMutex.Unlock()
	fake.ReadRouterGroupStub = stub
}

func (fake *FakeDB) ReadRouterGroupArgsForCall(i int) string {
	fake.readRouterGroupMutex.RLock()
	defer fake.readRouterGroupMutex.RUnlock()
	argsForCall := fake.readRouterGroupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDB) ReadRouterGroupReturns(result1 models.RouterGroup, result2 error) {
	fake.readRouterGroupMutex.Lock()
	defer fake.readRouterGroupMutex.Unlock()
	fake.ReadRouterGroupStub = nil
	fake.readRouterGroupReturns = struct {
		result1 models.RouterGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) ReadRouterGroupReturnsOnCall(i int, result1 models.RouterGroup, result2 error) {
	fake.readRouterGroupMutex.Lock()
	defer fake.readRouterGroupMutex.Unlock()
	fake.ReadRouterGroupStub = nil
	if fake.readRouterGroupReturnsOnCall == nil {
		fake.readRouterGroupReturnsOnCall = make(map[int]struct {
			result1 models.RouterGroup
			result2 error
		})
	}
	fake.readRouterGroupReturnsOnCall[i] = struct {
		result1 models.RouterGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) ReadRouterGroupByName(arg1 string) (models.RouterGroup, error) {
	fake.readRouterGroupByNameMutex.Lock()
	ret, specificReturn := fake.readRouterGroupByNameReturnsOnCall[len(fake.readRouterGroupByNameArgsForCall)]
	fake.readRouterGroupByNameArgsForCall = append(fake.readRouterGroupByNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ReadRouterGroupByName", []interface{}{arg1})
	fake.readRouterGroupByNameMutex.Unlock()
	if fake.ReadRouterGroupByNameStub != nil {
		return fake.ReadRouterGroupByNameStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.readRouterGroupByNameReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) ReadRouterGroupByNameCallCount() int {
	fake.readRouterGroupByNameMutex.RLock()
	defer fake.readRouterGroupByNameMutex.RUnlock()
	return len(fake.readRouterGroupByNameArgsForCall)
}

func (fake *FakeDB) ReadRouterGroupByNameCalls(stub func(string) (models.RouterGroup, error)) {
	fake.readRouterGroupByNameMutex.Lock()
	defer fake.readRouterGroupByNameMutex.Unlock()
	fake.ReadRouterGroupByNameStub = stub
}

func (fake *FakeDB) ReadRouterGroupByNameArgsForCall(i int) string {
	fake.readRouterGroupByNameMutex.RLock()
	defer fake.readRouterGroupByNameMutex.RUnlock()
	argsForCall := fake.readRouterGroupByNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDB) ReadRouterGroupByNameReturns(result1 models.RouterGroup, result2 error) {
	fake.readRouterGroupByNameMutex.Lock()
	defer fake.readRouterGroupByNameMutex.Unlock()
	fake.ReadRouterGroupByNameStub = nil
	fake.readRouterGroupByNameReturns = struct {
		result1 models.RouterGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) ReadRouterGroupByNameReturnsOnCall(i int, result1 models.RouterGroup, result2 error) {
	fake.readRouterGroupByNameMutex.Lock()
	defer fake.readRouterGroupByNameMutex.Unlock()
	fake.ReadRouterGroupByNameStub = nil
	if fake.readRouterGroupByNameReturnsOnCall == nil {
		fake.readRouterGroupByNameReturnsOnCall = make(map[int]struct {
			result1 models.RouterGroup
			result2 error
		})
	}
	fake.readRouterGroupByNameReturnsOnCall[i] = struct {
		result1 models.RouterGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) ReadRouterGroups() (models.RouterGroups, error) {
	fake.readRouterGroupsMutex.Lock()
	ret, specificReturn := fake.readRouterGroupsReturnsOnCall[len(fake.readRouterGroupsArgsForCall)]
	fake.readRouterGroupsArgsForCall = append(fake.readRouterGroupsArgsForCall, struct {
	}{})
	fake.recordInvocation("ReadRouterGroups", []interface{}{})
	fake.readRouterGroupsMutex.Unlock()
	if fake.ReadRouterGroupsStub != nil {
		return fake.ReadRouterGroupsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.readRouterGroupsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) ReadRouterGroupsCallCount() int {
	fake.readRouterGroupsMutex.RLock()
	defer fake.readRouterGroupsMutex.RUnlock()
	return len(fake.readRouterGroupsArgsForCall)
}

func (fake *FakeDB) ReadRouterGroupsCalls(stub func() (models.RouterGroups, error)) {
	fake.readRouterGroupsMutex.Lock()
	defer fake.readRouterGroupsMutex.Unlock()
	fake.ReadRouterGroupsStub = stub
}

func (fake *FakeDB) ReadRouterGroupsReturns(result1 models.RouterGroups, result2 error) {
	fake.readRouterGroupsMutex.Lock()
	defer fake.readRouterGroupsMutex.Unlock()
	fake.ReadRouterGroupsStub = nil
	fake.readRouterGroupsReturns = struct {
		result1 models.RouterGroups
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) ReadRouterGroupsReturnsOnCall(i int, result1 models.RouterGroups, result2 error) {
	fake.readRouterGroupsMutex.Lock()
	defer fake.readRouterGroupsMutex.Unlock()
	fake.ReadRouterGroupsStub = nil
	if fake.readRouterGroupsReturnsOnCall == nil {
		fake.readRouterGroupsReturnsOnCall = make(map[int]struct {
			result1 models.RouterGroups
			result2 error
		})
	}
	fake.readRouterGroupsReturnsOnCall[i] = struct {
		result1 models.RouterGroups
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) ReadRoutes() ([]models.Route, error) {
	fake.readRoutesMutex.Lock()
	ret, specificReturn := fake.readRoutesReturnsOnCall[len(fake.readRoutesArgsForCall)]
	fake.readRoutesArgsForCall = append(fake.readRoutesArgsForCall, struct {
	}{})
	fake.recordInvocation("ReadRoutes", []interface{}{})
	fake.readRoutesMutex.Unlock()
	if fake.ReadRoutesStub != nil {
		return fake.ReadRoutesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.readRoutesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) ReadRoutesCallCount() int {
	fake.readRoutesMutex.RLock()
	defer fake.readRoutesMutex.RUnlock()
	return len(fake.readRoutesArgsForCall)
}

func (fake *FakeDB) ReadRoutesCalls(stub func() ([]models.Route, error)) {
	fake.readRoutesMutex.Lock()
	defer fake.readRoutesMutex.Unlock()
	fake.ReadRoutesStub = stub
}

func (fake *FakeDB) ReadRoutesReturns(result1 []models.Route, result2 error) {
	fake.readRoutesMutex.Lock()
	defer fake.readRoutesMutex.Unlock()
	fake.ReadRoutesStub = nil
	fake.readRoutesReturns = struct {
		result1 []models.Route
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) ReadRoutesReturnsOnCall(i int, result1 []models.Route, result2 error) {
	fake.readRoutesMutex.Lock()
	defer fake.readRoutesMutex.Unlock()
	fake.ReadRoutesStub = nil
	if fake.readRoutesReturnsOnCall == nil {
		fake.readRoutesReturnsOnCall = make(map[int]struct {
			result1 []models.Route
			result2 error
		})
	}
	fake.readRoutesReturnsOnCall[i] = struct {
		result1 []models.Route
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) ReadTcpRouteMappings() ([]models.TcpRouteMapping, error) {
	fake.readTcpRouteMappingsMutex.Lock()
	ret, specificReturn := fake.readTcpRouteMappingsReturnsOnCall[len(fake.readTcpRouteMappingsArgsForCall)]
	fake.readTcpRouteMappingsArgsForCall = append(fake.readTcpRouteMappingsArgsForCall, struct {
	}{})
	fake.recordInvocation("ReadTcpRouteMappings", []interface{}{})
	fake.readTcpRouteMappingsMutex.Unlock()
	if fake.ReadTcpRouteMappingsStub != nil {
		return fake.ReadTcpRouteMappingsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.readTcpRouteMappingsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDB) ReadTcpRouteMappingsCallCount() int {
	fake.readTcpRouteMappingsMutex.RLock()
	defer fake.readTcpRouteMappingsMutex.RUnlock()
	return len(fake.readTcpRouteMappingsArgsForCall)
}

func (fake *FakeDB) ReadTcpRouteMappingsCalls(stub func() ([]models.TcpRouteMapping, error)) {
	fake.readTcpRouteMappingsMutex.Lock()
	defer fake.readTcpRouteMappingsMutex.Unlock()
	fake.ReadTcpRouteMappingsStub = stub
}

func (fake *FakeDB) ReadTcpRouteMappingsReturns(result1 []models.TcpRouteMapping, result2 error) {
	fake.readTcpRouteMappingsMutex.Lock()
	defer fake.readTcpRouteMappingsMutex.Unlock()
	fake.ReadTcpRouteMappingsStub = nil
	fake.readTcpRouteMappingsReturns = struct {
		result1 []models.TcpRouteMapping
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) ReadTcpRouteMappingsReturnsOnCall(i int, result1 []models.TcpRouteMapping, result2 error) {
	fake.readTcpRouteMappingsMutex.Lock()
	defer fake.readTcpRouteMappingsMutex.Unlock()
	fake.ReadTcpRouteMappingsStub = nil
	if fake.readTcpRouteMappingsReturnsOnCall == nil {
		fake.readTcpRouteMappingsReturnsOnCall = make(map[int]struct {
			result1 []models.TcpRouteMapping
			result2 error
		})
	}
	fake.readTcpRouteMappingsReturnsOnCall[i] = struct {
		result1 []models.TcpRouteMapping
		result2 error
	}{result1, result2}
}

func (fake *FakeDB) SaveRoute(arg1 models.Route) error {
	fake.saveRouteMutex.Lock()
	ret, specificReturn := fake.saveRouteReturnsOnCall[len(fake.saveRouteArgsForCall)]
	fake.saveRouteArgsForCall = append(fake.saveRouteArgsForCall, struct {
		arg1 models.Route
	}{arg1})
	fake.recordInvocation("SaveRoute", []interface{}{arg1})
	fake.saveRouteMutex.Unlock()
	if fake.SaveRouteStub != nil {
		return fake.SaveRouteStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveRouteReturns
	return fakeReturns.result1
}

func (fake *FakeDB) SaveRouteCallCount() int {
	fake.saveRouteMutex.RLock()
	defer fake.saveRouteMutex.RUnlock()
	return len(fake.saveRouteArgsForCall)
}

func (fake *FakeDB) SaveRouteCalls(stub func(models.Route) error) {
	fake.saveRouteMutex.Lock()
	defer fake.saveRouteMutex.Unlock()
	fake.SaveRouteStub = stub
}

func (fake *FakeDB) SaveRouteArgsForCall(i int) models.Route {
	fake.saveRouteMutex.RLock()
	defer fake.saveRouteMutex.RUnlock()
	argsForCall := fake.saveRouteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDB) SaveRouteReturns(result1 error) {
	fake.saveRouteMutex.Lock()
	defer fake.saveRouteMutex.Unlock()
	fake.SaveRouteStub = nil
	fake.saveRouteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) SaveRouteReturnsOnCall(i int, result1 error) {
	fake.saveRouteMutex.Lock()
	defer fake.saveRouteMutex.Unlock()
	fake.SaveRouteStub = nil
	if fake.saveRouteReturnsOnCall == nil {
		fake.saveRouteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveRouteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) SaveRouterGroup(arg1 models.RouterGroup) error {
	fake.saveRouterGroupMutex.Lock()
	ret, specificReturn := fake.saveRouterGroupReturnsOnCall[len(fake.saveRouterGroupArgsForCall)]
	fake.saveRouterGroupArgsForCall = append(fake.saveRouterGroupArgsForCall, struct {
		arg1 models.RouterGroup
	}{arg1})
	fake.recordInvocation("SaveRouterGroup", []interface{}{arg1})
	fake.saveRouterGroupMutex.Unlock()
	if fake.SaveRouterGroupStub != nil {
		return fake.SaveRouterGroupStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveRouterGroupReturns
	return fakeReturns.result1
}

func (fake *FakeDB) SaveRouterGroupCallCount() int {
	fake.saveRouterGroupMutex.RLock()
	defer fake.saveRouterGroupMutex.RUnlock()
	return len(fake.saveRouterGroupArgsForCall)
}

func (fake *FakeDB) SaveRouterGroupCalls(stub func(models.RouterGroup) error) {
	fake.saveRouterGroupMutex.Lock()
	defer fake.saveRouterGroupMutex.Unlock()
	fake.SaveRouterGroupStub = stub
}

func (fake *FakeDB) SaveRouterGroupArgsForCall(i int) models.RouterGroup {
	fake.saveRouterGroupMutex.RLock()
	defer fake.saveRouterGroupMutex.RUnlock()
	argsForCall := fake.saveRouterGroupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDB) SaveRouterGroupReturns(result1 error) {
	fake.saveRouterGroupMutex.Lock()
	defer fake.saveRouterGroupMutex.Unlock()
	fake.SaveRouterGroupStub = nil
	fake.saveRouterGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) SaveRouterGroupReturnsOnCall(i int, result1 error) {
	fake.saveRouterGroupMutex.Lock()
	defer fake.saveRouterGroupMutex.Unlock()
	fake.SaveRouterGroupStub = nil
	if fake.saveRouterGroupReturnsOnCall == nil {
		fake.saveRouterGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveRouterGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) SaveTcpRouteMapping(arg1 models.TcpRouteMapping) error {
	fake.saveTcpRouteMappingMutex.Lock()
	ret, specificReturn := fake.saveTcpRouteMappingReturnsOnCall[len(fake.saveTcpRouteMappingArgsForCall)]
	fake.saveTcpRouteMappingArgsForCall = append(fake.saveTcpRouteMappingArgsForCall, struct {
		arg1 models.TcpRouteMapping
	}{arg1})
	fake.recordInvocation("SaveTcpRouteMapping", []interface{}{arg1})
	fake.saveTcpRouteMappingMutex.Unlock()
	if fake.SaveTcpRouteMappingStub != nil {
		return fake.SaveTcpRouteMappingStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.saveTcpRouteMappingReturns
	return fakeReturns.result1
}

func (fake *FakeDB) SaveTcpRouteMappingCallCount() int {
	fake.saveTcpRouteMappingMutex.RLock()
	defer fake.saveTcpRouteMappingMutex.RUnlock()
	return len(fake.saveTcpRouteMappingArgsForCall)
}

func (fake *FakeDB) SaveTcpRouteMappingCalls(stub func(models.TcpRouteMapping) error) {
	fake.saveTcpRouteMappingMutex.Lock()
	defer fake.saveTcpRouteMappingMutex.Unlock()
	fake.SaveTcpRouteMappingStub = stub
}

func (fake *FakeDB) SaveTcpRouteMappingArgsForCall(i int) models.TcpRouteMapping {
	fake.saveTcpRouteMappingMutex.RLock()
	defer fake.saveTcpRouteMappingMutex.RUnlock()
	argsForCall := fake.saveTcpRouteMappingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDB) SaveTcpRouteMappingReturns(result1 error) {
	fake.saveTcpRouteMappingMutex.Lock()
	defer fake.saveTcpRouteMappingMutex.Unlock()
	fake.SaveTcpRouteMappingStub = nil
	fake.saveTcpRouteMappingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) SaveTcpRouteMappingReturnsOnCall(i int, result1 error) {
	fake.saveTcpRouteMappingMutex.Lock()
	defer fake.saveTcpRouteMappingMutex.Unlock()
	fake.SaveTcpRouteMappingStub = nil
	if fake.saveTcpRouteMappingReturnsOnCall == nil {
		fake.saveTcpRouteMappingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveTcpRouteMappingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDB) UnlockRouterGroupReads() {
	fake.unlockRouterGroupReadsMutex.Lock()
	fake.unlockRouterGroupReadsArgsForCall = append(fake.unlockRouterGroupReadsArgsForCall, struct {
	}{})
	fake.recordInvocation("UnlockRouterGroupReads", []interface{}{})
	fake.unlockRouterGroupReadsMutex.Unlock()
	if fake.UnlockRouterGroupReadsStub != nil {
		fake.UnlockRouterGroupReadsStub()
	}
}

func (fake *FakeDB) UnlockRouterGroupReadsCallCount() int {
	fake.unlockRouterGroupReadsMutex.RLock()
	defer fake.unlockRouterGroupReadsMutex.RUnlock()
	return len(fake.unlockRouterGroupReadsArgsForCall)
}

func (fake *FakeDB) UnlockRouterGroupReadsCalls(stub func()) {
	fake.unlockRouterGroupReadsMutex.Lock()
	defer fake.unlockRouterGroupReadsMutex.Unlock()
	fake.UnlockRouterGroupReadsStub = stub
}

func (fake *FakeDB) UnlockRouterGroupWrites() {
	fake.unlockRouterGroupWritesMutex.Lock()
	fake.unlockRouterGroupWritesArgsForCall = append(fake.unlockRouterGroupWritesArgsForCall, struct {
	}{})
	fake.recordInvocation("UnlockRouterGroupWrites", []interface{}{})
	fake.unlockRouterGroupWritesMutex.Unlock()
	if fake.UnlockRouterGroupWritesStub != nil {
		fake.UnlockRouterGroupWritesStub()
	}
}

func (fake *FakeDB) UnlockRouterGroupWritesCallCount() int {
	fake.unlockRouterGroupWritesMutex.RLock()
	defer fake.unlockRouterGroupWritesMutex.RUnlock()
	return len(fake.unlockRouterGroupWritesArgsForCall)
}

func (fake *FakeDB) UnlockRouterGroupWritesCalls(stub func()) {
	fake.unlockRouterGroupWritesMutex.Lock()
	defer fake.unlockRouterGroupWritesMutex.Unlock()
	fake.UnlockRouterGroupWritesStub = stub
}

func (fake *FakeDB) WatchChanges(arg1 string) (<-chan db.Event, <-chan error, context.CancelFunc) {
	fake.watchChangesMutex.Lock()
	ret, specificReturn := fake.watchChangesReturnsOnCall[len(fake.watchChangesArgsForCall)]
	fake.watchChangesArgsForCall = append(fake.watchChangesArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("WatchChanges", []interface{}{arg1})
	fake.watchChangesMutex.Unlock()
	if fake.WatchChangesStub != nil {
		return fake.WatchChangesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.watchChangesReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeDB) WatchChangesCallCount() int {
	fake.watchChangesMutex.RLock()
	defer fake.watchChangesMutex.RUnlock()
	return len(fake.watchChangesArgsForCall)
}

func (fake *FakeDB) WatchChangesCalls(stub func(string) (<-chan db.Event, <-chan error, context.CancelFunc)) {
	fake.watchChangesMutex.Lock()
	defer fake.watchChangesMutex.Unlock()
	fake.WatchChangesStub = stub
}

func (fake *FakeDB) WatchChangesArgsForCall(i int) string {
	fake.watchChangesMutex.RLock()
	defer fake.watchChangesMutex.RUnlock()
	argsForCall := fake.watchChangesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDB) WatchChangesReturns(result1 <-chan db.Event, result2 <-chan error, result3 context.CancelFunc) {
	fake.watchChangesMutex.Lock()
	defer fake.watchChangesMutex.Unlock()
	fake.WatchChangesStub = nil
	fake.watchChangesReturns = struct {
		result1 <-chan db.Event
		result2 <-chan error
		result3 context.CancelFunc
	}{result1, result2, result3}
}

func (fake *FakeDB) WatchChangesReturnsOnCall(i int, result1 <-chan db.Event, result2 <-chan error, result3 context.CancelFunc) {
	fake.watchChangesMutex.Lock()
	defer fake.watchChangesMutex.Unlock()
	fake.WatchChangesStub = nil
	if fake.watchChangesReturnsOnCall == nil {
		fake.watchChangesReturnsOnCall = make(map[int]struct {
			result1 <-chan db.Event
			result2 <-chan error
			result3 context.CancelFunc
		})
	}
	fake.watchChangesReturnsOnCall[i] = struct {
		result1 <-chan db.Event
		result2 <-chan error
		result3 context.CancelFunc
	}{result1, result2, result3}
}

func (fake *FakeDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cancelWatchesMutex.RLock()
	defer fake.cancelWatchesMutex.RUnlock()
	fake.deleteRouteMutex.RLock()
	defer fake.deleteRouteMutex.RUnlock()
	fake.deleteRouterGroupMutex.RLock()
	defer fake.deleteRouterGroupMutex.RUnlock()
	fake.deleteTcpRouteMappingMutex.RLock()
	defer fake.deleteTcpRouteMappingMutex.RUnlock()
	fake.lockRouterGroupReadsMutex.RLock()
	defer fake.lockRouterGroupReadsMutex.RUnlock()
	fake.lockRouterGroupWritesMutex.RLock()
	defer fake.lockRouterGroupWritesMutex.RUnlock()
	fake.readFilteredTcpRouteMappingsMutex.RLock()
	defer fake.readFilteredTcpRouteMappingsMutex.RUnlock()
	fake.readRouterGroupMutex.RLock()
	defer fake.readRouterGroupMutex.RUnlock()
	fake.readRouterGroupByNameMutex.RLock()
	defer fake.readRouterGroupByNameMutex.RUnlock()
	fake.readRouterGroupsMutex.RLock()
	defer fake.readRouterGroupsMutex.RUnlock()
	fake.readRoutesMutex.RLock()
	defer fake.readRoutesMutex.RUnlock()
	fake.readTcpRouteMappingsMutex.RLock()
	defer fake.readTcpRouteMappingsMutex.RUnlock()
	fake.saveRouteMutex.RLock()
	defer fake.saveRouteMutex.RUnlock()
	fake.saveRouterGroupMutex.RLock()
	defer fake.saveRouterGroupMutex.RUnlock()
	fake.saveTcpRouteMappingMutex.RLock()
	defer fake.saveTcpRouteMappingMutex.RUnlock()
	fake.unlockRouterGroupReadsMutex.RLock()
	defer fake.unlockRouterGroupReadsMutex.RUnlock()
	fake.unlockRouterGroupWritesMutex.RLock()
	defer fake.unlockRouterGroupWritesMutex.RUnlock()
	fake.watchChangesMutex.RLock()
	defer fake.watchChangesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.DB = new(FakeDB)
